# Abstract와 Interface

추상클래스와 인터페이스의 차이를 말하면 항상 추상클래스보다 추상화 정도가 높다, 추상화클래스를 미완성 설계도, 인터페이스를 기본 설계도로 비유하곤 한다.

### 추상클래스

클래스가 전체적인 구성을 가지지 못하고 설계만 되어 있는 클래스를 말한다. 미완성 설계도로써 추상클래스로 인스턴스를 생성할 수 없다.

- 추상메서드가 0개 이상 (추상메서드가 없어도 가능)
- 일반메서드를 가질 수 있다
- 일반 변수를 가질 수 있다

### 인터페이스

인터페이스는 추상메서드를 가지지만 구현부를 구현하지 않고 선언부만을 가지며 추상클래스가 미완성 설계도라면 인터페이스는 밑 바탕만 그려둔 기본설계도라 불린다.

- 메서드는 추상메서드만 가질 수 있다 (JAVA 1.8 부터는 Default 메서드 사용가능)
- 일반 변수를 가질 수 없다

### 추상클래스의 용도

아이폰과 갤럭시라는 클래스가 존재하고 이를 추상클래스로 추상화 하려고 한다면 공통된 부분을 가장 먼저 뽑아내어 클래스를 만들것이다.

```
  class 아이폰 {
    void 전화받기() { ... }
    void 전화걸기() { ... }
    스토어 열기() { ... }
  }

  class 갤럭시 {
    void 전화받기() { ... }
    void 전화걸기() { ... }
    void 스토어 열기() {...}
  }
```

핸드폰이라는 추상클래스를 만들고 전화걸기(), 전화받기()와 같은 공통적인 부분을 뽑아내었다.

```
  abstract class 핸드폰 {
    void 전화받기() { ... }
    void 전화걸기() { ... }
    abstract  void 스토어 열기() {}
  }

  class 아이폰 extends 핸드폰 {
    스토어 열기() { /* 앱 스토어를 열어라 */ }
  }

  class 갤럭시 extends 핸드폰 {
    스토어 열기() { /* 구글 스토어를 열어라 */ }
  }
```

핸드폰 클래스를 정의함으로써 다른 핸드폰 기종이 생길때마다 전화를 걸고 받는 부분에 대한 기능을 재활욜 할 수 있다.  
(상세하게 전화를 걸고 받는 부분에 다른 점이 있을 수 있으나 번호를 누르고 전화를 걸고 전화를 받는 동작은 동일하다고 가정하고...)  
핸드폰을 상속받은 클래스들은 모두 전화를 받고 거는 부분은 공통적이지만 스토어를 여는 부분에 있어서는 제공하는 스토어의 종류가  
다르기 때문에 스토어 열기()에 대한 메서드는 추상메서드로 정의한다. 또 핸드폰의 경우 스토어는 반드시 필요한 기능이기에  
추상메서드로 선언을 하게 된다면 반드시 이를 구현해야한다는 의미가 된다.

### 인터페이스의 용도 - 1

```
  abstract class 핸드폰 {
    void 전화받기() { ... }
    void 전화걸기() { ... }
    abstract  void 스토어 열기() {}
  }

  class 아이폰 extends 핸드폰 {
    스토어 열기() { /* 앱 스토어를 열어라 */ }
  }

  class 갤럭시 extends 핸드폰 {
    스토어 열기() { /* 구글 스토어를 열어라 */ }
  }

  class 고아라폰 extends 핸드폰 {
    스토어 열기() { /* 네이트 스토어를 열어라 */ }
  }
```

예를 들어 피쳐폰인 고아라폰이 새롭게 추가가 된다고 하면 스마트폰과 피쳐폰에 대한 구분이 필요해진다.  
이를 구별 하는 클래스를 만들어서 상속을 받으려고 해도 이미 핸드폰이라는 클래스를 상속받고 있기 때문에  
클래스를 구현해도 의미가 없다. 이런경우에 인터페이스를 활용할 수 있다.

```
  interface 스마트폰 {
    void 와이파이연결() {}
  }

  abstract class 핸드폰 {
    void 전화받기() { ... }
    void 전화걸기() { ... }
    abstract  void 스토어 열기() {}
  }

  class 아이폰 extends 핸드폰 implements 스마트폰 {
    스토어 열기() { /* 앱 스토어를 열어라 */ }
    와이파이연결() { ... }
  }

  class 갤럭시 extends 핸드폰 implements 스마트폰  {
    스토어 열기() { /* 구글 스토어를 열어라 */ }
    와이파이연결() { ... }
  }

  class 고아라폰 extends 핸드폰 {
    스토어 열기() { /* 네이트 스토어를 열어라 */ }
  }
```

와이파이 연결의 경우는 핸드폰이라는 조상클래스에 정의를 한다고 하면 피쳐폰의 경우는 해당 클래스를 가져와 사용이 불가능 해진다.  
그렇기 때문에 이를 인터페이스로 구현하고 스마트폰으로 나온 아이폰과 갤럭시에 인터페이스를 구현해주도록 처리를 한다.

### 인터페이스의 용도 - 2

인터페이스를 통해서 구현한 클래스는 해당 인터페이스를 조상이라 할 수 있으므로 인터페이스 타입의 참조변수로 이를 구현한 클래스의  
인스턴스를 참조할 수 있다. 이를 통해서 다형성의 이점을 활용하는 프로그래밍이 가능해진다.

사용자들이 뷰어를 사용하는 과정에서 엑셀파일, 한글파일, PPT파일등 어떤 파일이 들어와도 뷰어를 통해 파일을 보는 기능은 지장이 없다 해당 부분을 우리가 흔히 스프링에서 사용하는 Serveice와 ServiceImpl 방식에 빗대어 생각해보면 Service 부분은 ViewerService라는 인터페이스가 되는것이고 HwpViewerServiceImpl, XlsxViewerServiceOmpl, PowerPointViewer를 구현한 것이다.

이 과정에서 각 ~ViewerServiceImpl들은 ViewerService에 구현된 뷰어기능을 각 파일에 맞게 구현한 것이다. 이를 통해서 상황에 맞는 Service로 구현체를 사용하면 Controller에서는 다른 변경 사항이 없이 서비스를 그대로 사용하면 되는 이점을 가진다.
